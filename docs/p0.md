# Project 0: Getting Real

## Preliminaries

>Fill in your name and email address.

Jiaqi Si sigongzi@stu.pku.edu.cn

>If you have any preliminary comments on your submission, notes for the TAs, please give them here.



>Please cite any offline or online sources you consulted while preparing your submission, other than the Pintos documentation, course text, lecture notes, and course staff.



## Booting Pintos

>A1: Put the screenshot of Pintos running example here.

running by bochs

![bochsOK](/home/sigongzi/os/pintos/exercise0.1.jpg)

running by qemu

![qemu](/home/sigongzi/os/pintos/qemu.jpg)

## Debugging

#### QUESTIONS: BIOS 

>B1: What is the first instruction that gets executed?

ljmp $0xf000, $0xe05b

>B2: At which physical address is this instruction located?

physical address: 0xffff0


#### QUESTIONS: BOOTLOADER

>B3: How does the bootloader read disk sectors? In particular, what BIOS interrupt is used?

use BIOS interrupt call (under the real mode, by instruction **int**)

int **0x14** ah 0x00 INITIALIZE PORT

al = 0xe3 = 0b11100011

dx=0x0 (for COM1 and 0x1 for COM2... and so on)

this table is copy from [INT0x14](https://www.plantation-productions.com/Webster/www.artofasm.com/DOS/ch13/CH13-3.html)

| Bits | Function         |
| ---- | ---------------- |
| 5..7 | Select baud rate |
|      | 000- 110 baud |
|      |001- 150|
| |010- 300|
| |011- 600|
| |100- 1200|
| |101- 2400|
| |110- 4800|
| |111- 9600|
| 3..4 |Select parity|
|  |00- No parity|
|  |01- Odd parity|
|  |10- No parity|
|  |11- Even parity|
| 2 |Stop bits|
|  |0- One stop bit|
|  |1- Two stop bits|
| 0..1 |Character Size|
|  |10- 7bits|
|  |11- 8bits|


Serial Port Initialization (from [BIOS wiki](https://en.wikipedia.org/wiki/BIOS_interrupt_call) )

5..7 111- Select 9600 baud rate

3..4 00- Select No parity (parity bit for check)

2 0 One stop bit

0..1 11- Select Character size (8 bits)



call ***read_sector*** which sends **0x13** interrupt to BIOS

- int 0x13 ah 0x42 EXTENDED READ
- dl 0x80 hard disk 1 (we may add this number to check next disk if this disk doesn't have partition)
- DS:SI SI select data segment and **si** is the top of the stack(mov %sp, %si)
- the specific information about Disk Address Packet [INT 0x13 wiki](https://en.wikipedia.org/wiki/INT_13H#INT_13h_AH=42h:_Extended_Read_Sectors_From_Drive)

| offset   | size    | content       | description                          |
| -------- | ------- | ------------- | ------------------------------------ |
| 00h      | 1 Byte  | 0x10          | size of DAP (always set to 0x10)     |
| 01h      | 1 Byte  | 0             | unused, should be zero               |
| 02h..03h | 2 Bytes | 0x1           | Number of sectors to read            |
| 04h..05h | 2 Bytes | 0x0 0x0       | Buffer offset                        |
| 06h..07h | 2 Bytes | %es = 0x20000 | Buffer segment                       |
| 08h..0Fh | 4 Bytes | 0x00 0x0 0x0  | LBA sector number (we read sector 0) |




>B4: How does the bootloader decides whether it successfully finds the Pintos kernel?

if ***read_sector*** fails, the **CF** flag set on error

When the disk read fails, jc condition (CF = 1) is met, so the instruction change pc to ***no_such_drive***

If we read a disk to 0x20000 successfully, we check the ***MBR signature*** of the hard disk (0xaa55 for the two bytes in the first sector)

If the signature check fails, we try to find the **next_drive**

If it is the partitioned hard disk we need, we check whether the partition is a Pintos kernel (0x20 in 0x201c2)and a bootable partition(0x80 in 0x201be)

If the check fails, we will try **next_partition**

Or we find the next hard disk

After above checking, we jump to ***load_kernel*** 


>B5: What happens when the bootloader could not find the Pintos kernel?

The execute stream comes to the assembly code with label ***no_such_drive*** or ***no_boot_partition***

we print error information **Not found**

and send **0x18** interrupt call to BIOS (Called when there is no bootable disk available to the system [INT0x18](http://www.ctyme.com/intr/rb-2241.htm))

>B6: At what point and how exactly does the bootloader transfer control to the Pintos kernel?

(The space is so scarce that the author had to use the code text segment. I was shocked.)  

we reading the whole kernel (must less than 512KiB) from 0x20000 to 0x9ffff

in 0x7cd3 physical address a long jump to the *start in kernel


#### QUESTIONS: KERNEL

>B7: At the entry of pintos_init(), what is the value of expression `init_page_dir[pd_no(ptov(0))]` in hexadecimal format?

![B7](/home/sigongzi/os/pintos/B7-select.jpg)

hexadecimal format: 0x0

pdov: physical address to virtual address (after pdov) -> (void * 0xc0000000 + 0)

pd_no: get page directory index (after pd_no) -> (uint) (0b1100000000 -> 0x300)

init_page_dir: we have not initialized it already...



>B8: When `palloc_get_page()` is called for the first time,

>> B8.1 what does the call stack look like?
>
>![stack](/home/sigongzi/os/pintos/B8.1.jpg)
>
>**start** call **pintos_init**
>
>**pintos_init** call **paging_init**
>
>**paging_init** call **palloc_get_page**

>> B8.2 what is the return value in hexadecimal format?
>
>![B8.2](/home/sigongzi/os/pintos/B8.2.jpg)
>
>return **0xc0101000**
>
>an virtual address direct mapping to physical address 

>> B8.3 what is the value of expression `init_page_dir[pd_no(ptov(0))]` in hexadecimal format?
>
>**you still have NOT initialized page table here yet!!!! why I need to take a  screenshot again?**
>
>![B8.3](/home/sigongzi/os/pintos/B8.3.jpg)
>
>it is 0x0



>B9: When palloc_get_page() is called for the third time,

>> B9.1 what does the call stack look like?
>
>![B9.1](/home/sigongzi/os/pintos/B9.1.jpg)
>
>**start** call **pintos_init**
>
>**pintos_init** call **thread_start**
>
>**thread_start** call **thread_create**
>
>**thread_create** call **palloc_get_page**
>
>it is called in function **thread_create**

>> B9.2 what is the return value in hexadecimal format?
>
>it returns 0xc0103000
>
>which means we allocate the third page

>> B9.3 what is the value of expression `init_page_dir[pd_no(ptov(0))]` in hexadecimal format?
>
>value: 0x102027
>
>a PDE entry
>
>0x102 physical index of this page frame
>
>0x027 = 0b 0000 0010 0111
>
>ACCESS BIT(5)
>
>USER BIT(2)
>
>WRITABLE BIT(1)
>
>PRESENT BIT(0)



## Kernel Monitor

>C1: Put the screenshot of your kernel monitor running example here. (It should show how your kernel shell respond to `whoami`, `exit`, and `other input`.)



![shell](/home/sigongzi/os/pintos/shell.jpg)



>C2: Explain how you read and write to the console for the kernel monitor.

firstly, the command need to be cached, so it can not be infinite long. 

Buffer size is 64, so the maximal command line is 63. (to left a position for end character '\0')

The size is defined as a marco definition and can be changed easily.

  

### handle input

The two special inputs we need to handle are that **backspace**(ascii 0x8) and **carriage return**(ascii 0xD)



#### backspace

The VGA helps us do the cursor move. But we can not delete the charater which has been already printed.

A tricky method is that using space(ascii 0x20) to cover it.

When we receive a backspace. we transmit backspace(0x8) + space(0x20) + backspace(0x8), 3 characters totally, to VGA

The user is to believe that we can really delete his input!



#### carriage return

0xD is the end of a command line. We use this value to check that input for this time is end.



#### printable character

The ascii code for printable character is between 0x20 and 0x7e.

We just use **putchar** to append it to STDOUT



#### too long input

We record the length of input. If the length reaches MAXCOMMANDLINE - 1, we terminate the getting process.

Tell the naughty user the shell is unwilling to handle command too long and clear the input buffer by **input_init**



### handle command line

#### whoami

**print** my student id



#### exit

call **shutdown_power_off** to exit qemu



#### other input

we **print** the command we cached in input handling.

and **print** " invalid" after it. 
